// controllers/books.go

package controllers

import (
	"context"
	"fmt"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	"golang.org/x/crypto/bcrypt"

	_ "k8sAPI/docs" // docs is generated by Swag CLI, you have to import it.
	"k8sAPI/models"
	"k8sAPI/structs"

	appsv1 "k8s.io/api/apps/v1"
	apiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
)

const K8sNamespace = "test"

func Config() *kubernetes.Clientset {
	var kubeconfig = ""

	if home := homedir.HomeDir(); home != "" {
		kubeconfig = filepath.Join(home, ".kube", "config")
	} else {
		kubeconfig = ""
	}
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		panic(err)
	}
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err)
	}
	return clientset
}

func int32Ptr(i int32) *int32 { return &i }

/* 아래 항목이 swagger에 의해 문서화 된다. */
// @Tags k8s Pod/Service api
// @Summary k8s Deployment Service Create
// @Description create pod & service
// @name CreateKubeService
// @Accept json
// @Produce json
// @Router /k8s/create-pod-service [post]
// @Param data body structs.CreatePodServiceParam true "파라미터 설명"
func CreateKubeService(c *gin.Context) {
	var input structs.CreatePodServiceParam

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	nowDate := time.Now().Format("20060102")                                       // 시간 포맷
	userName := "shiftone"                                                         // userId - 임의값
	userPass := "tempUserPass"                                                     // userPw - 임의값
	pwHash, _ := bcrypt.GenerateFromPassword([]byte(userPass), bcrypt.DefaultCost) // pw hash
	option := input.Option                                                         // template
	version := input.Ver                                                           // opt ver
	releaseVersion := option + "-" + version                                       // img ver  before option_id
	podName := userName + "-" + releaseVersion + "-" + nowDate                     // podname  before podName
	inputPodName := strings.ToLower(podName)                                       // podname 소문자 podName
	portNum := input.PortNum                                                       // port
	label := input.Label

	// var inputPodName string = podName
	var image models.K8s_Image_List
	db := c.MustGet("db").(*gorm.DB)
	if err := db.Where("option_id = ?", releaseVersion).First(&image).Error; err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Record not found!"})
		return
	}
	imageName := image.ImageName
	deploymentsClient := Config().AppsV1().Deployments(K8sNamespace)

	deployment := &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name: inputPodName,
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: int32Ptr(1),
			Selector: &metav1.LabelSelector{
				MatchLabels: map[string]string{
					"app": inputPodName,
				},
			},
			Template: apiv1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"app": inputPodName,
					},
				},
				Spec: apiv1.PodSpec{
					Containers: []apiv1.Container{
						{
							Name:  "web",
							Image: imageName,
							Ports: []apiv1.ContainerPort{},
						},
					},
				},
			},
		},
	}

	for i, port := range input.Port {
		temp := apiv1.ContainerPort{Name: "http" + strconv.Itoa(i+1), Protocol: apiv1.ProtocolTCP, ContainerPort: int32(port)}
		deployment.Spec.Template.Spec.Containers[0].Ports = append(deployment.Spec.Template.Spec.Containers[0].Ports, temp)
		dbInputDetailRes := models.K8s_Pod_Detail{
			PodName:     podName,
			Port:        port,
			PortName:    "http" + strconv.Itoa(i+1),
			PodProtocol: "TCP",
			Namespace:   K8sNamespace,
		}
		db.Create(&dbInputDetailRes)
	}

	// Create Deployment
	fmt.Println("Creating deployment...")
	result, err := deploymentsClient.Create(context.TODO(), deployment, metav1.CreateOptions{})
	if err != nil {
		c.JSON(400, gin.H{"error": "deployment Create Fail"})
		return
		panic(err)
	}
	fmt.Printf("Created deployment %q.\n", result.GetObjectMeta().GetName())

	dbInputListRes := models.K8s_Pod_List{
		UserName:   userName,
		UserPass:   pwHash,
		Label:      label,
		PodName:    podName,
		PortNum:    portNum,
		ImageName1: imageName,
		ImageName2: "image2",
		ImageName3: "image3",
		ImageName4: "image4",
		Option:     option,
		OptionVer:  version,
	}

	db.Create(&dbInputListRes)

	serviceInputName := strings.ReplaceAll(inputPodName, ".", "") //서비스명에는 . 이 들어갈 수 없음
	service := &apiv1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name: serviceInputName,
		},
		Spec: apiv1.ServiceSpec{
			Selector: map[string]string{
				"app": inputPodName,
			},
			Type:  "NodePort",
			Ports: []apiv1.ServicePort{},
		},
	}

	for i, port := range input.Port {
		temp := apiv1.ServicePort{Name: "http" + strconv.Itoa(i+1), Port: int32(port), TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: int32(port)}}
		service.Spec.Ports = append(service.Spec.Ports, temp)
		dbInputServiceDetailRes := models.K8s_Service_Detail{
			ServiceName: serviceInputName,
			PortName:    "http" + strconv.Itoa(i+1),
			Port:        port,
			Namespace:   K8sNamespace,
		}

		db.Create(&dbInputServiceDetailRes)
	}

	// Run Service
	fmt.Println("Running service...")
	svc, err := Config().CoreV1().Services(K8sNamespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		c.JSON(400, gin.H{"error": "service execute Fail"})
		// panic(err)
		return
	}
	fmt.Printf("Service running  %q.\n", svc.GetObjectMeta().GetName())

	dbInputServiceListRes := models.K8s_Service_List{
		ServiceName: serviceInputName,
		PodName:     podName,
		PortNum:     portNum,
		ServiceType: "NodePort",
		Namespace:   K8sNamespace,
	}

	db.Create(&dbInputServiceListRes)
}

// -
/* 아래 항목이 swagger에 의해 문서화 된다. */
// @Tags k8s Pod/Service api
// @Summary k8s Service Start
// @Description start service
// @Param data body structs.ServiceStartParam true "파라미터 설명"
// @Accept json
// @Produce json
// @Router /k8s/start-service [post]
func StartService(c *gin.Context) {
	var input structs.ServiceStartParam

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var inputPodName string = input.PodName
	serviceInputName := strings.ReplaceAll(inputPodName, ".", "") //서비스명에는 . 이 들어갈 수 없음

	var portRes []structs.PodPortInfoRes

	db := c.MustGet("db").(*gorm.DB)
	//SELECT B.port FROM k8s_pod_lists A JOIN k8s_pod_details B ON A.pod_name = B.pod_name
	db.Table("k8s_pod_lists A").Select("B.port as port").Joins("join k8s_pod_details B on A.pod_name = B.pod_name").Where("A.pod_name = ?", inputPodName).Scan(&portRes)

	service := &apiv1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name: serviceInputName,
		},
		Spec: apiv1.ServiceSpec{
			Selector: map[string]string{
				"app": inputPodName,
			},
			Type:  "NodePort",
			Ports: []apiv1.ServicePort{},
		},
	}
	for i := 0; i < len(portRes); i++ {
		var port int = portRes[i].Port
		temp := apiv1.ServicePort{Name: "http" + strconv.Itoa(i+1), Port: int32(port), TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: int32(port)}}
		service.Spec.Ports = append(service.Spec.Ports, temp)
		dbInputServiceDetailRes := models.K8s_Service_Detail{
			ServiceName: serviceInputName,
			PortName:    "http" + strconv.Itoa(i+1),
			Port:        port,
			Namespace:   K8sNamespace,
		}

		db.Create(&dbInputServiceDetailRes)
	}

	// Run Service
	fmt.Println("Running service...")
	svc, err := Config().CoreV1().Services(K8sNamespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		c.JSON(400, gin.H{"error": "service execute Fail"})
		panic(err)
	}

	dbInputServiceListRes := models.K8s_Service_List{
		ServiceName: serviceInputName,
		PodName:     inputPodName,
		PortNum:     strconv.Itoa(len(portRes)),
		ServiceType: "NodePort",
		Namespace:   K8sNamespace,
	}

	db.Create(&dbInputServiceListRes)

	fmt.Printf("Service running  %q.\n", svc.GetObjectMeta().GetName())
}

/* 아래 항목이 swagger에 의해 문서화 된다. */
// @Tags k8s Pod/Service api
// @Summary k8s Deployment Delete
// @Description delete pod
// @Accept json
// @Produce json
// @Param data body structs.DeletePodServiceParam true "파라미터 설명"
// @Router /k8s/delete-pod-service [delete]
func DeleteKubeService(c *gin.Context) {
	var input structs.DeletePodServiceParam

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var appName string = input.PodName
	deploymentsClient := Config().AppsV1().Deployments(K8sNamespace)
	serviceClient := Config().CoreV1().Services(K8sNamespace)
	deletePolicy := metav1.DeletePropagationForeground

	if err := serviceClient.Delete(context.TODO(), strings.ReplaceAll(appName, ".", ""), metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}); err != nil {
		fmt.Print("에러 없어서 따로처리해야함")
		// panic(err)
	} else {
		fmt.Println("Deleted service")
	}

	db := c.MustGet("db").(*gorm.DB)

	var dbInputServiceDetailRes models.K8s_Service_Detail
	db.Where("service_name = ?", strings.ReplaceAll(appName, ".", "")).Delete(&dbInputServiceDetailRes)

	var dbInputServiceListRes models.K8s_Service_List
	db.Where("service_name = ?", strings.ReplaceAll(appName, ".", "")).Delete(&dbInputServiceListRes)

	if err := deploymentsClient.Delete(context.TODO(), appName, metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}); err != nil {
		panic(err)
	} else {
		fmt.Println("Deleted deployment")
	}

	var dbInputDetailRes models.K8s_Pod_Detail
	db.Where("pod_name = ?", appName).Delete(&dbInputDetailRes)

	var dbInputListRes models.K8s_Pod_List
	db.Where("pod_name = ?", appName).Delete(&dbInputListRes)
}

/* 아래 항목이 swagger에 의해 문서화 된다. */
// @Tags k8s Pod/Service api
// @Summary k8s Service Stop
// @Description delete pod
// @Accept json
// @Produce json
// @Param data body structs.DeletePodServiceParam true "파라미터 설명"
// @Router /k8s/stop-service [delete]
func StopService(c *gin.Context) {
	var input structs.DeletePodServiceParam

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var appName string = input.PodName
	serviceClient := Config().CoreV1().Services(K8sNamespace)
	deletePolicy := metav1.DeletePropagationForeground

	if err := serviceClient.Delete(context.TODO(), strings.ReplaceAll(appName, ".", ""), metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}); err != nil {
		fmt.Print("에러 없어서 따로처리해야함")
		// panic(err)
	} else {
		fmt.Println("Deleted service")
	}

	db := c.MustGet("db").(*gorm.DB)

	var dbInputServiceDetailRes models.K8s_Service_Detail
	db.Where("service_name = ?", strings.ReplaceAll(appName, ".", "")).Delete(&dbInputServiceDetailRes)

	var dbInputServiceListRes models.K8s_Service_List
	db.Where("service_name = ?", strings.ReplaceAll(appName, ".", "")).Delete(&dbInputServiceListRes)
}
